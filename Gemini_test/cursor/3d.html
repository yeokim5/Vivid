<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Perfect - 3D Scrollytelling</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/"
        }
      }
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Roboto:wght@300;400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-color: #0a0a0a;
        --text-color: #f5f5f5;
        --accent-color: #e2c07c;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        margin: 0;
        overflow-x: hidden;
        background: #0a0a0a;
        color: var(--text-color);
        font-family: "Roboto", sans-serif;
      }

      canvas {
        position: fixed;
        top: 0;
        left: 0;
        z-index: 1;
      }

      .content {
        position: relative;
        z-index: 2;
        pointer-events: none;
      }

      section {
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        position: relative;
      }

      .scroll-indicator {
        position: absolute;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        opacity: 0.7;
        color: white;
        font-size: 2rem;
        animation: bounce 2s infinite;
      }

      @keyframes bounce {
        0%,
        20%,
        50%,
        80%,
        100% {
          transform: translateY(0) translateX(-50%);
        }
        40% {
          transform: translateY(-20px) translateX(-50%);
        }
        60% {
          transform: translateY(-10px) translateX(-50%);
        }
      }

      .credits {
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        font-size: 0.8rem;
        opacity: 0.5;
        z-index: 3;
      }
    </style>
  </head>
  <body>
    <div class="content">
      <section id="section-0" data-text="Perfect">
        <div class="scroll-indicator">â†“</div>
      </section>
      <section id="section-1" data-text="I found a love for me"></section>
      <section id="section-2" data-text="Beautiful and sweet"></section>
      <section
        id="section-3"
        data-text="We were just kids when we fell in love"
      ></section>
      <section id="section-4" data-text="Your heart is all I own"></section>
      <section
        id="section-5"
        data-text="Dancing in the dark with you between my arms"
      ></section>
      <section
        id="section-6"
        data-text="Darling you look perfect tonight"
      ></section>
      <section id="section-7" data-text="She shares my dreams"></section>
      <section
        id="section-8"
        data-text="To carry children of our own"
      ></section>
      <section id="section-9" data-text="We're so in love"></section>
      <section
        id="section-10"
        data-text="I see my future in your eyes"
      ></section>
      <section id="section-11" data-text="You look perfect tonight"></section>
    </div>

    <div class="credits">3D Scrollytelling Experience</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <script type="module">
      import * as THREE from "three";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

      // Register GSAP plugins
      gsap.registerPlugin(ScrollTrigger);

      // Set up THREE.js scene
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 20, 50);
      camera.lookAt(0, 5, 0);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x0a0a0a);
      document.body.appendChild(renderer.domElement);

      // Ground plane to receive light glow
      const groundGeometry = new THREE.PlaneGeometry(200, 200);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x111122,
        roughness: 0.8,
        metalness: 0.3,
        side: THREE.DoubleSide,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);

      // Ambient light for basic visibility
      const ambientLight = new THREE.AmbientLight(0x222233, 0.3);
      scene.add(ambientLight);

      // Point light to simulate moonlight shining down
      const mainLight = new THREE.PointLight(0x99ccff, 1.5, 100);
      mainLight.position.set(0, 30, 10);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 1024;
      mainLight.shadow.mapSize.height = 1024;
      mainLight.shadow.radius = 4;
      scene.add(mainLight);

      // Second colored light for variety
      const accentLight = new THREE.PointLight(0xffaa66, 1.2, 80);
      accentLight.position.set(-20, 25, 10);
      scene.add(accentLight);

      let currentTextMesh = null;
      let targetText = "Perfect";
      let font;
      let animating = false;

      // Load font
      const loader = new FontLoader();
      loader.load(
        "https://cdn.jsdelivr.net/npm/three@0.154.0/examples/fonts/helvetiker_regular.typeface.json",
        (loadedFont) => {
          font = loadedFont;
          createText(targetText);
          setupScrollTriggers();
        }
      );

      function createText(text) {
        if (!font) return;

        if (currentTextMesh) {
          // If there's existing text, prepare to remove it after animation
          const oldMesh = currentTextMesh;
          gsap.to(oldMesh.position, {
            y: -10,
            opacity: 0,
            duration: 1,
            onComplete: () => scene.remove(oldMesh),
          });
        }

        // Create new text geometry
        const textGeo = new TextGeometry(text, {
          font: font,
          size: text.length > 20 ? 2 : 3.5,
          height: 0.7,
          curveSegments: 12,
          bevelEnabled: true,
          bevelThickness: 0.2,
          bevelSize: 0.15,
          bevelSegments: 3,
        });

        // Center text geometry
        textGeo.computeBoundingBox();
        const centerOffset =
          -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
        textGeo.translate(centerOffset, 0, 0);

        // Material with emissive glow
        const textMaterial = new THREE.MeshStandardMaterial({
          color: 0x99ccff,
          emissive: 0x4466ff,
          emissiveIntensity: 0.9,
          metalness: 0.5,
          roughness: 0.3,
        });

        currentTextMesh = new THREE.Mesh(textGeo, textMaterial);
        currentTextMesh.position.y = 8;
        currentTextMesh.position.z = 0;
        currentTextMesh.castShadow = true;
        scene.add(currentTextMesh);

        // Animate text coming in
        gsap.from(currentTextMesh.position, {
          y: 20,
          duration: 1.5,
          ease: "power3.out",
        });

        return currentTextMesh;
      }

      function setupScrollTriggers() {
        const sections = document.querySelectorAll("section");

        sections.forEach((section) => {
          ScrollTrigger.create({
            trigger: section,
            start: "top center",
            end: "bottom center",
            markers: false,
            onEnter: () => {
              if (animating) return;
              animating = true;

              // Change color theme based on section index
              const sectionIndex = parseInt(section.id.split("-")[1]);
              const colors = [
                { text: 0x99ccff, emissive: 0x4466ff, light: 0x99ccff },
                { text: 0xffaa88, emissive: 0xff7744, light: 0xffaa88 },
                { text: 0xaaddff, emissive: 0x66aaff, light: 0xaaddff },
                { text: 0xffccaa, emissive: 0xff9966, light: 0xffccaa },
                { text: 0xaaffee, emissive: 0x66ddcc, light: 0xaaffee },
                { text: 0xffddaa, emissive: 0xffbb77, light: 0xffddaa },
                { text: 0xccaaff, emissive: 0x9977ff, light: 0xccaaff },
                { text: 0xffaacc, emissive: 0xff7799, light: 0xffaacc },
                { text: 0xe2c07c, emissive: 0xc9a45e, light: 0xe2c07c },
                { text: 0xaaffcc, emissive: 0x77ffaa, light: 0xaaffcc },
                { text: 0xffaa66, emissive: 0xff8844, light: 0xffaa66 },
                { text: 0xddffaa, emissive: 0xbbff77, light: 0xddffaa },
              ];

              const color = colors[sectionIndex % colors.length];

              // Update light color
              gsap.to(mainLight.color, {
                r: new THREE.Color(color.light).r,
                g: new THREE.Color(color.light).g,
                b: new THREE.Color(color.light).b,
                duration: 1,
              });

              // Get text from data attribute
              const newText = section.dataset.text;
              targetText = newText;

              // Create new text
              createText(newText);

              setTimeout(() => {
                animating = false;
              }, 1000);
            },
          });
        });
      }

      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();

        // Animate light intensity
        mainLight.intensity = 1.2 + 0.3 * Math.sin(elapsed * 1.5);
        accentLight.intensity = 1.0 + 0.4 * Math.sin(elapsed * 2.2 + 1.3);

        // Gentle movement for the text
        if (currentTextMesh) {
          currentTextMesh.position.y = 7.5 + 0.4 * Math.sin(elapsed * 1.8);
          currentTextMesh.rotation.y = 0.05 * Math.sin(elapsed * 0.8);

          if (currentTextMesh.material) {
            currentTextMesh.material.emissiveIntensity =
              0.7 + 0.5 * Math.sin(elapsed * 2);
          }
        }

        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
